## 多语言框架服务
---

### 前言
> 在项目中集成多语言框架服务，目前市面上并没有现成的开源框架来提供这方面的基础服务，因此，这边基于`express` + `tsoa`的项目基础上，从0开始搭建关于项目的多语言支持框架服务。下面将针对整个搭建的过程进行详细的介绍，以及在后续的项目coding过程中，应该需要注意的地方!

### 需求
> 在项目实际业务开发过程中，一般地，我不想再编写重复冗余的代码，应该让这个多语言支持的工作，类似于java中的面向切面编程的思维，在不需要此多语言的服务时，可以方便地移除掉，也就是支持热拔插的方式，另外，用来存储这个多语言的collection，应该是不同的业务存储在不同的collection中的，不能将所有的业务语言数据存储在同一个collection，对于后续的升级扩展不够友好，而且还又可能导致推倒重建的可能性，整个自动翻译的过程，应该是对于后端服务而言，是无感的，零侵入的，最后，不一定所有的业务都需要多语言支持的，需要可以支持按需集成，而不是一刀切的方式！
> 将上述的需求简单概括下，就是以下的几个点：
1. 支持热拔插，可随时添加或者移除；
2. 与单语言开发无异，不能增加原本逻辑的复杂度；
3. 多collection存储对应的业务语言数据；
4. 多语言存储过程自动进行，无需人工干预

### 一. 纯本地json语言文件框架搭建
> 在项目的过程中，有一些语言描述需要返回给客户端端进行描述展示，因此需要根据客户端请求的语言类型进行对应的展示

#### 1. 安装`i18next`全家桶
> 本项目借助于`i18next`全家桶，来提供基于请求的多语言服务框架支持，以及对应的库结合来提供基础的多语言服务
```shell
	pnpm install --save i18next i18next-http-middleware i18next-fs-backend
```

#### 2. 创建自定义语言中间件，尽量在较前位置调用语言中间件
> 创建语言中间件，并使用该中间件
```typescript
import Logger from '@/utils/Logger'
import { Express } from 'express'
import i18next from 'i18next'
import languageMW from 'i18next-http-middleware'
import Backend from 'i18next-fs-backend'
import path from 'path'

export default function(app: Express) {
	// languageMW.LanguageDetector是一个语言检测器，主要用于从req中监测到对应的语言
	i18next.use(Backend).use(languageMW.LanguageDetector).init({
		debug: true,
		preload: ['en', 'zh-CN', 'zh-TW'],
		backend: {
			loadPath: path.join(__dirname, `../locales/{{lng}}.json`),
			addPath: path.join(__dirname, `../locales/{{lng}}.missing.json`)
		},
		fallbackLng: 'en',
		interpolation: {
			escapeValue: false  // 关闭HTML转义
		}
	}, () => {
		//! 加载成功
		Logger.debug('语言加载成功')
	})
	// 这里的handle最终也是返回一个中间件函数:(req, res, next) => {}
	app.use(languageMW.handle(i18next))
}
```
:star2: 这里的`Backend`是`i18next`的一个插件，代表的是将采用怎样的方式来加载对应的语言文件，这个语言文件还是与其他的项目一样，根据名称，存储在`/locales/**.json`中，而在这个`i18next`中的backend对应配置加载的规则，`preload`则指定预先加载的资源。

#### 3. 调用该中间件
```typescript
import LanguageMW from './middleware/LanguageMW';
const app = express();
LanguageMW(app)	// 语言安装包中间件，在最先的地方调用该中间件
```

#### 4. typescript检测
> 在使用了该中间件之后，将在`Request`对象中追加相关的语言属性
```typescript
export interface Request {
			//! 以下是i18next-http-middleware中间件追加的属性
			i18n: i18n,				// i18next实例
			t: i18n['t'],			// 公共的语言翻译函数
			language: string,	// 当前请求的语言code 
			languages: string[],	// 可回单支持的语言code数组
			lng: string,					// 当前请求的语言code，等价于language
			locale: string,		// 当前请求的语言code，等价于language
		}
```
:star2: 于是这样子，我们则可以直接在`req.t('key')`来自动加载对应的语言了！！

### 二. 数据存取多语言框架搭建
> 在项目动态化业务存取中，需要结合数据库进行语言数据的存取操作，下面将详细介绍搭建的过程

#### 1. 提供基础的翻译服务工具类
> 提供统一的翻译服务工具类，用于针对不同的业务语言进行翻译的服务
```typescript
import Logger from '@/utils/Logger';
import { Model, Types } from 'mongoose'
export class TranslateService<T> {
	// 与业务collection关联的语言collection的model，用于语言doc的存取
	private translateModel: Model<T>;
	constructor(model: Model<T>){
		this.translateModel = model
	}
	/**
	 * 根据业务id以及对应的目标语言来获取语言数据
	*/
	getTranslate(id: Types.ObjectId | string, language: string) {
		//TODO 执行相关的db查询操作
		console.info('获取对应语言model中对应语言的数据', language)
		Logger.debug('获取对应语言model中对应语言的数据', language)
		// this.translateModel.find()
	}
	/**
	 * 根据业务id来更新对应的语言数据
	*/
	updateTranslates(id: Types.ObjectId | string, language: string, updates: any) {
		//TODO 执行相关的更新操作
		Logger.debug('缓存翻译数据')
	}
}
```
:star2: 这个`TranslageService`是一个范型的class，可接收`Model`类型参数，实现与对应的语言数据Model进行捆绑，提供两个API，用于根据业务id以及所请求的语言来获取对应的语言数据，以及根据/存储新的语言数据到Model中！

#### 2. 提供基于`mongoose`的插件
> 提供统一的`mongoose`插件，在插件中通过提供对应的中间件，以及追加的设置语言的方法，来实现从`req`到`mongoose`插件的数据传递
```typescript
import { TranslateService } from '@/service/TranslateService'
import Logger from '@/utils/Logger'
import { Schema, Model } from 'mongoose'
/**
 * 翻译插件的自定义参数
*/
export type TranslatePluginOptions = {
	/**
	 * 当前的模型名称，用于获取当前业务模型所需要翻译的keys
	*/
	modelName: string,
	model: any,
	/**
	 * modalName模型对应需要翻译的字段key名称集合
	*/
	keysInCollection: string[],
	translateModel?: string
}
// 缓存的collection与需要翻译的key的映射关系
const cachedModelKeys: Record<string, string[]> = {}
/**
 * 可按需调用的翻译插件
*/
export const TranslatePlugin = (schema: Schema, options: TranslatePluginOptions) => {
	// 获取调用插件时传递的model类型
	type ServiceType = typeof options.model
	// 在collection注册好插件时，也就创建好了对应的翻译服务
	const tService: TranslateService<ServiceType> = new TranslateService(options.model)
	cachedModelKeys[options.modelName] = options.keysInCollection
	schema.method('setLanguage', function(language: string) {
		let doc = this as any
		doc.language = language;
	})
	schema.pre('save', function(next) {
		console.info(this)
		const doc = this as any
		//? 拿到req中的language
		const language = doc.language
		Logger.debug('--->' + language + '<---')
		// tService.updateTranslates()
		Logger.debug('这里将在保存动作自动追加翻译数据到翻译表中')
		next()
	})
	schema.post(['find', 'findOne', 'findOneAndUpdate'], function(doc, next) {
		console.info(doc)
		const query = this as any
		console.info(query.options)
		//? 拿到req中的language
		const language = query.language
		Logger.debug('--->' + language)
		//TODO 这里将通过service自动从对应的collection中获取到对应的翻译数据
		// tService.getTranslate(doc.id, language)
		Logger.debug('这里将自动追加上翻译信息')
		next()
	})
}
```
:star2: 在上述的插件中，主要针对`schema`的实例追加了一个`setLanguage`方法，使得对应的model也拥有了这样子的方法api，当需要多语言支持的时候，将`req.language`给设置到对应的文档doc对象中，然后在对应的保存(save)等动作中，将获取到这个`language`来进行多语言查询动作

#### 3. 需要的collection直接注册这个插件
> 由于支持按需集成多语言，在对应的`schema`中去集成这样子的插件
```typescript
// ProductModel.ts
// 注册需要使用翻译服务的插件
productSchema.plugin(TranslatePlugin, {
	modelName: MODEL_NAME,	// 传递当前的model名称
	model: TProductModel,		// 传递对应的语言Model
	keysInCollection: T_PRODUCT_KEYS	// 传递需要存储的key的集合
})
```
:star2: 当注册这个插件的时候，将创建一个对应的翻译服务，该翻译服务自动将业务collection(products)与对应的语言collection(tProducts)给捆绑起来了，实现一个自动化关联，并在后续自动翻译的过程！

#### 4. 调用Model的调整，实现req参数传递
> 通过`mongoose`框架，我们可以直接调用创建出来的`Model`对象的api来实现数据的增删查改操作，因此我们在对应的`Controller`中，可以直接借助于`Model`来将`req.language`进行传输
```typescript
export ProductController extends BaseController{
	// 通过new出Model来调用的实例方法的方式，在Model实例中调用setLanguage的方式
	@Put('publish')
	@Middlewares(validateProductMW)
	public async createProduct(@Request() req: ExpressRequest, @Body() params: any): Promise<BaseObjectEntity<string>> {
		const createAProductModel = new ProductModel(params)
		createAProductModel.setLanguage(req.language)
	}

	// 调用Model的静态方法方式，直接传递参数的方式
	@Post('{id}/onOrOff')
	public async upOrDownAProduct(@Request() req: ExpressRequest, @Path() id: string) {
		const updateAProduct = await ProductModel.findByIdAndUpdate(id, {
			$set: { state }
		}, { runValidators: true, lauguage: req.language })
	}

	// 调用Model的静态方法方式，也可以通过setOptions来实现
	@Get('{id}')
	public async getAProduct(@Request() req: ExpressRequest, @Path() id: string): Promise<BaseObjectEntity<ProductDTO>> {
		const findAProduct = await ProductModel.findOne({ _id: new ObjectId(id) }).setOptions({language: req.language});
	}
}
```
:stars: 这里针对不同类型的中间件(比如时查询中间件还是文档中间件)，提供两种不同的调用方式

#### 5. typescript类型检测支持
> 由于我们所需要创建的语言DTO类型需要可以在对应的model中调用`setLanguage`方法，因此，需要将这个方法定义到对应的语言Model中，也就是Schema中，而这个Schema来自于我们自定义的DTO中，因此，我们可以将其抽离出来，封装成为一个基类接口，有实际的业务逻辑去按需集成
```typescript
	// 基类语言DTO
	export interface LanguageDTO {
		setLanguage(language: string);

	}
	// 需要多语言支持的业务
	export interface ProductDTO extends LanguageDTO {}
```
:star: 这样子之后，我们再由`ProductDTO` -> `ProductSchema` -> `ProductModel`创建出来的`ProductModel`则可以直接调用这个`setLanguage`方法了！