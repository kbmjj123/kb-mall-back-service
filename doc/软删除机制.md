## 软删除机制
---

### 前言
> 为防止在项目coding的过程中自己或者其他同事不小心误删数据，或者使用不正当的方式删掉了数据，因此，在项目中将删除操作给“回收”掉，然后提供另外一种零影响的方式来实现删除操作：**软删除**

### 软删除概念
> `软删除`就是在程序中通过提供编辑的方式来实现与`删除`操作一致的逻辑，使得程序在正常实现系统业务逻辑的情况下，又能够保证数据的完整性，用户在查询的时候，自动过滤掉已“被删除”的数据！

### 需求
> 要实现全系统的软删除机制，需要满足以下几个点：
1. 一键集成，无需手动式地、编写重复的代码来实现(因为个人比较懒)；
2. 尽量不影响原来的执行操作(像查询、删除、编辑操作等等)；
3. 最好是查询出来的数据，看不出来是采用了软删除的操作；
4. typescript支持。

### 实现
> :point_down: 将具体整理整个软删除的实现过程

#### 1. 覆盖适用所有的数据collection，追加软删除所需参数
> 当前项目采用的是`mongoose`来实现的数据层访问机制，因此，借助于`mongoose`的**插件机制**，来给所有的数据表`collection`添加软删除服务，自定义以下插件：
```typescript
import { Query, Schema } from 'mongoose'
export type SoftDeleteOptions = {}
/**
 * 自定义的mongoose插件，通过schema来对所有的colletion进行干预
*/
export const SoftDeletePlugin = (schema: Schema, options: SoftDeleteOptions) => {
	schema.add({
		createTime: { type: Date, default: Date.now, select: false },
		modifyTime: { type: Date, default: Date.now, select: false },
		deleteTime: { type: Date, default: null, select: false }
	})
}
```
:star2: 上述我们定义了一个自定义插件，在该插件中通过对`schema.add()`方法的调用，来实现追加的自定义字段：`createTime`、`modifyTime`、`deleteTime`，而且这里我们还制定了这三个属性的`select=false`，关于这个`select`的属性相关说明见[官网](https://mongoosejs.com/docs/api/schematypeoptions.html#SchemaTypeOptions.prototype.select)，简而言之，就是当查询的时候，是否要将这几个字段给查询出来！

:star2: 通过上述插件的执行，所有的collection都将拥有软删除的相关参数，但是，实际上这三个值并没有被赋值，因此，我们需要对其进行赋值并存储！

#### 2. 对软删除的相关属性进行赋值
```typescript
export const SoftDeletePlugin = (schema: Schema) => {
	schema.pre<ISoftDeleteDTO>('save', function(next) {
		if(!this.createTime){
			//? 如果目标文档对象是第一次创建的，添加创建时间
			this.createTime = new Date()
		}
		this.modifyTime = new Date()
		next()
	})
}
```
:star2: 上述我们通过借助于`schema.pre('save')`，在其回调方法(数据表记录的保存动作)中，对所有的记录在**编辑、保存**的时候，进行软删除相关属性的赋值，使得数据表记录在编辑与删除的时候，都自动更新当前服务器的时间。

:thinking: 注意这里我们在`schema.pre('save')`方法中限定了参数化类型：`ISoftDeleteDTO`，意思是只有拥有该类型下的相关参数的记录的编辑与删除操作才有效，这是为了限定我们在编码时，提供一个提示作用！关于这个`ISoftDeleteDTO`的定义如下：
```typescript
/**
 * 作为项目中所有collection的schema所继承的基础接口，提供软删除相关的字段属性
 */
export interface ISoftDeleteDTO {
	/**
	 * 记录创建时间
	 */
	createTime?: Date,
	/**
	 * 记录修改时间
	*/
	modifyTime?: Date,
	/**
	 * 记录删除时间
	*/
	deleteTime?: Date| null,
}
```

#### 3. 自定义统一的软删除操作
> 在程序中提供给开发者调用的统一“软删除”操作，来实现对应的删除业务：
```typescript
export const SoftDeletePlugin = (schema: Schema) => {
	//? 提供公共的实例对象的软删除方法给每个实例
	schema.method('softDelete', function() {
		this.deleteTime = new Date()
		return this.save()
	})
	//? 提供批量根据查询条件来进行软删除操作
	schema.static('softDeleteMany', function(query) {
		return this.updateMany(query, { deleteTime: new Date() })
	})
}
```
:+1: 通过上述提供在实例对象中的方法以及在静态方法中提供删除的方式，给到`schema`，也就是对应的`model`拥有了对应的方法可以直接执行，调用过程如下所示：
```typescript
// 通过实例的方式来调用
	const user = UserModel.findOne({id: 'xxx'})
	user && user.softDelete()
	// 通过静态方法的方式来调用
	UserMode.softDeleteMany({name: 'kbmjj123'})
```

#### 4. 查询时根据“已删除”状态进行过滤数据
```typescript
export const SoftDeletePlugin = (schema: Schema) => {
//? 定义公共的软删除的默认查询操作-> 自动过滤掉有删除时间deleteTime的记录
	const softDeleteFilter = function(this: Query<any, any>, next: Function){
		this.where({ deleteTime: null })
		next()
	}
	schema.pre('find', softDeleteFilter)
	schema.pre('findOne', softDeleteFilter)
	schema.pre('findOneAndUpdate', softDeleteFilter)
	schema.pre('countDocuments', softDeleteFilter)
	schema.pre('estimatedDocumentCount', softDeleteFilter)
}
```
:star: 由于我们第三步实现的删除时将记录的`deleteTime`给赋值为当前的时间，因此查询的时候，也仅仅是筛选这个`deleteTime`为空的记录即可实现过滤掉“已删除”的记录！

#### 5. 重载删除操作，避免误调用
> 通过重写`mongoose.schema`自带的删除数据动作，防止开发者误调用删除导致数据丢失：
```typescript
export const SoftDeletePlugin = (schema: Schema) => {
	//! 以下是覆盖的mongoose的model的原本的相关删除方法，防止开发者错误调用，导致数据丢失
	const deleteMethods = [
		'deleteOne', 'deleteMany', 'findByIdAndDelete', 'findOneAndDelete'
	]
	const handleDelete = () => {
		throw new Error('无法直接调用删除方法，请调用softDelete()来替代下！')
	}
	deleteMethods.forEach(item => {
		schema.statics[item] = handleDelete
	})
}
```

#### 6. typescript支持
> 由于项目是采用的`typescript`来编写的，当调用对象的一个运行时才存在属性/方法的时候，`typescript`编译器将提示可能的编码错误，因为我们需要“告诉”`typescript`编译器，某些对象的确是拥有这些属性/方法的
```typescript
	// 让所有需要软删除支持的schema对应的DTO都继承于`ISoftDeleteDTO`，从而拥有相关的属性以及方法
	export class ProductDTO extends ISoftDeleteDTO {
		// ... 这里是商品的相关属性定义
	}
```
:thinking: 另外，由于我们是调用的model对象的实例方法来实现单个记录的删除的，因此，还需要在全局的类型定义中，追加我们的自定义方法api
```typescript
// types/mongoose.d.ts
import { Document } from 'mongoose';

declare module 'mongoose' {
  // 扩展 mongoose.Model 接口
  interface Model<T extends Document> {
		//? 针对所有的Model提供静态化的softDeleteMany方法
    softDeleteMany(conditions: any): Promise<any>;
  }
}

```