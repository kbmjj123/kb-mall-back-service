## 日志服务
---

### 前言
> 需要在项目集成自动化的日志服务机制，以便于在项目过程中方便跟踪问题，而并非是单纯地将此功能转交给第三方日志服务系统，像是`sentry`等等。
> 根据实际问题的追溯情况，要跟踪一个问题，一般需要满足以下需求

### 需求
> 上述5个点的的实现，必须是免手动挡方式来调用的，也就是无需显示手动调用日志记录的api，而是让这个过程自动记录，自动发生并记录到对应的日志文件中:
1. 用户发起请求所携带的相关信息；
2. 进行数据库操作时，所携带的db相关参数以及对应的动作；
3. 接口响应时传递的数据；
4. 日志记录，正常应该按照每天的一个文档的方式来记录，而且如果当天文件过大的话，超出阀值部分将自动记录到另外一个文档中(即轮转)；
5. 日志的动作，可以通过环境变量进行对应的开关控制配置，一键开启与关闭

### 技术实现
> 针对上述提及的几个点的需求，进行一一实现，为在日志文件中查找具体的问题，针对不同场景下的日志记录，提供自定义的开头(比如像是`[Request Begin]`)这样子

#### 1. 在所有的请求中自动记录请求以及携带的相关信息
```typescript
import morgan, { TokenIndexer } from 'morgan';//友好输出请求日志信息
import { Express, Request, Response } from 'express'
import Logger from '@/utils/Logger';
export const loggerWrap = (app: Express) => {
	app.use(morgan((tokens: TokenIndexer<Request, Response>, req: Request, res: Response) => {
		return [
			`[Request Begin]:`,
			`Request URL: ${tokens.url(req, res)}`,
			`Method: ${tokens.method(req, res)}`,
			`Status: ${tokens.status(req, res)}`,
			`Response Time: ${tokens['response-time'](req, res)}ms`,
			`Content Length: ${tokens.res(req, res, 'content-length')}-`,
			`User-Agent: ${req.headers['user-agent']}`,
			`Client IP: ${req.clientIp}`
		].join('\n')
	}, {
		stream: {
			write(message: string) {
				Logger.info(message)
			}
		}
	}))
}
```
:star2: 上述代码中，我们包装了一个`loggerWrap`日志包装函数，通过借助于`morgan`中间件，实现日志信息的输出以及重定向写入到文件中，这里我们做了三个动作：
+. 自定义`morgan`的请求日志格式，重载了请求信息的组装格式，使得生成的日志按照我们所想要的效果进行记录；
+. 通过`request-ip`中间件库的引用，对客户端ip地址的获取并记录；
+. 传递`morgan`的`options`中的`stream`属性，将原本输出到控制台的信息流，转移给`log4js`

#### 2. 数据库操作日志自动记录
```typescript
	// DbConnection.ts
	//! 开启数据库日志调试
	mongoose.set('debug', function(collectionName, methodName, query: any, doc: any, options: any) {
	const messageList = [
		`[DB Operation]:`,
		`Collection: ${collectionName}`,
		`Db Method: ${methodName}`,
	]
	if(query){
		messageList.push(`Query: ${JSON.stringify(query)}`)
	}
	if(doc){
		messageList.push(`Doc: ${JSON.stringify(doc)}`)
	}
	if(options){
		messageList.push(`Options: ${JSON.stringify(options)}`)
	}
	Logger.info(messageList.join('\n'))
})
```
:star2: 通过`mongoose`的`set()`方法，可在其`debug`属性中，赋值一回调函数，该回调函数将会在数据库做的任何操作时，自动触发，并通过参数来获取当下的数据库操作所执行到的相关元素，我们可以从其中获取到对应的相关信息，并转交给`log4js`进行统一的记录

#### 3. 记录接口响应的信息
> 由于我们使用的是`tsoa`的`*Controller`来对接口进行响应的，而且之前我们也自定义了一个`BaseController.ts`，在这个基类中定义了一系列的方法API来给子类调用，从而输出统一的格式，那么可以在这个API方法中进行相关的日志记录，如下代码所示：
```typescript
export class BaseController extends Controller{
	/**
	 * 记录响应信息到日志中
	*/
	private logResponse<T>(data: BaseObjectEntity<T>) {
		Logger.info('[Response Data]')
		Logger.info(JSON.stringify(data))
	}
	protected successResponse<T>(req: ExpressRequest, data: T, message: string = ''): BaseObjectEntity<T> {
		const result =  {
			status: LogicResult.SUCCESS,
			message,
			data
		}
		this.logResponse(result)
		return result
	}
}
```
:star2: 最后也是将动作转交给`log4js`来进行统一的记录

#### 4. 日志轮转配置
```typescript
import Log4js from "log4js";
Log4js.configure({
	appenders: {
    out: { type: 'stdout' },
    app: { type: 'dateFile', filename: 'logs/application.log', pattern: '.yyyy-MM-dd', keepFileExt: true },
    errorFile: { type: 'dateFile', filename: 'logs/errors.log', pattern: '.yyyy-MM-dd', keepFileExt: true }
  },
  categories: {
    default: { appenders: ['out', 'app'], level: 'debug' },
    error: { appenders: ['out', 'errorFile'], level: 'error' }
  }
})
const Logger = Log4js.getLogger()
Logger.level = 'debug'
export default Logger
```
:star2: 通过借助于`Log4js`的`dateFile`类型的`appender`，来实现按天进行日志划分的功能，上述的配置，将会对应地在logs目录中创建`application.yyyy-MM-DD.log`的日志文件

#### 5. 环境变量加持


### 与pm2的结合